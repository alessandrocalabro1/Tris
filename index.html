<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tris & Scacchi Premium</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --container-bg: #1e293b;
            --text-color: #f8fafc;
            --accent-primary: #38bdf8;
            --accent-secondary: #f472b6;
            --grid-line: #334155;
            --hover-cell: #334155;
            --font-main: 'Segoe UI', system-ui, sans-serif;

            /* Chess Colors */
            --chess-light: #e2e8f0;
            --chess-dark: #475569;
            --chess-highlight: rgba(56, 189, 248, 0.5);
            --chess-moved: rgba(244, 114, 182, 0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .app-container {
            background-color: var(--container-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 550px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.6s ease-out;
            position: relative;
        }

        h1 {
            text-align: center;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* --- MENU SYSTEM --- */
        .view-section {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
        }

        .view-section.active {
            display: flex;
            animation: fadeIn 0.4s ease-out;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--grid-line);
            border-radius: 1rem;
            padding: 2rem 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .game-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-5px);
            border-color: var(--accent-primary);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .game-icon {
            font-size: 3rem;
        }

        .game-title {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .back-btn {
            background: transparent;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: -1rem;
            width: fit-content;
        }

        .back-btn:hover {
            opacity: 1;
            color: var(--accent-primary);
        }

        /* --- COMMON GAME CONTROLS --- */
        .settings,
        .scores {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 0.75rem;
        }

        .control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            font-size: 0.85rem;
            font-weight: 600;
            opacity: 0.8;
        }

        select,
        button.control-btn {
            background: var(--bg-color);
            color: white;
            border: 1px solid var(--grid-line);
            padding: 0.4rem 0.8rem;
            border-radius: 0.4rem;
            cursor: pointer;
            font-family: inherit;
        }

        .status-bar {
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            min-height: 1.5em;
        }

        .btn-action {
            width: 100%;
            padding: 0.8rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
            background: linear-gradient(135deg, var(--accent-primary), #0284c7);
            color: white;
            transition: opacity 0.2s;
        }

        .btn-action:hover {
            opacity: 0.9;
        }

        /* --- TRIS STYLES --- */
        .tris-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            aspect-ratio: 1;
        }

        .cell-tris {
            background: var(--bg-color);
            border-radius: 1rem;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            cursor: pointer;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        .cell-tris:hover:not(:disabled) {
            background: var(--hover-cell);
            transform: translateY(-2px);
        }

        .cell-tris.x {
            color: var(--accent-primary);
            text-shadow: 0 0 10px rgba(56, 189, 248, 0.4);
        }

        .cell-tris.o {
            color: var(--accent-secondary);
            text-shadow: 0 0 10px rgba(244, 114, 182, 0.4);
        }

        .cell-tris.win {
            background: rgba(255, 255, 255, 0.1);
            animation: pulse 1.5s infinite;
        }

        /* --- CHESS STYLES --- */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 4px solid var(--container-bg);
            aspect-ratio: 1;
            user-select: none;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2rem;
            cursor: pointer;
            position: relative;
        }

        .square.light {
            background-color: var(--chess-light);
            color: black;
        }

        .square.dark {
            background-color: var(--chess-dark);
            color: white;
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px var(--accent-primary);
        }

        .square.possible-move::after {
            content: '';
            width: 12px;
            height: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            position: absolute;
        }

        .square.capture-move::after {
            content: '';
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 0, 0, 0.4);
            border-radius: 50%;
            position: absolute;
        }

        .piece {
            cursor: grab;
            transition: transform 0.1s;
        }

        .piece.white {
            color: #f8fafc;
            text-shadow: 0 2px 2px rgba(0, 0, 0, 0.5);
        }

        .piece.black {
            color: #000000;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
        }

        /* --- ANIMATIONS --- */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.2);
            }

            70% {
                box-shadow: 0 0 0 10px transparent;
            }

            100% {
                box-shadow: 0 0 0 0 transparent;
            }
        }

        @media (max-width: 400px) {
            .app-container {
                padding: 1rem;
            }

            .cell-tris {
                font-size: 2.5rem;
            }

            .square {
                font-size: 1.8rem;
            }
        }
    </style>
</head>

<body>

    <div class="app-container">
        <h1 id="app-title">MASHFROG GAMES</h1>

        <!-- MENU VIEW -->
        <div id="view-menu" class="view-section active">
            <div class="menu-grid">
                <div class="game-card" onclick="Views.open('tris')">
                    <div class="game-icon">❌⭕</div>
                    <div class="game-title">TRIS</div>
                    <div style="font-size: 0.8rem; opacity: 0.7;">Classic</div>
                </div>
                <div class="game-card" onclick="Views.open('chess')">
                    <div class="game-icon">♟️</div>
                    <div class="game-title">SCACCHI</div>
                    <div style="font-size: 0.8rem; opacity: 0.7;">Strategia</div>
                </div>
            </div>
        </div>

        <!-- TRIS VIEW -->
        <div id="view-tris" class="view-section">
            <button class="back-btn" onclick="Views.open('menu')">← Menu</button>

            <div class="settings">
                <div class="control-group">
                    <label>Modalità</label>
                    <select id="tris-mode" onchange="TrisGame.reset()">
                        <option value="pvp">PvP Locale</option>
                        <option value="pvcpu">vs CPU</option>
                    </select>
                </div>
                <div class="control-group" id="tris-diff-group" style="display:none;">
                    <label>Difficoltà</label>
                    <select id="tris-diff" onchange="TrisGame.reset()">
                        <option value="easy">Facile</option>
                        <option value="hard">Impossibile</option>
                    </select>
                </div>
                <div class="control-group">
                    <span class="status-bar" id="tris-status">Start!</span>
                </div>
            </div>

            <div class="tris-board" id="tris-board"></div>
            <button class="btn-action" onclick="TrisGame.reset()">Nuova Partita</button>
        </div>

        <!-- CHESS VIEW -->
        <div id="view-chess" class="view-section">
            <button class="back-btn" onclick="Views.open('menu')">← Menu</button>

            <div class="settings" style="margin-bottom: 0.5rem;">
                <div class="control-group">
                    <label>Modalità</label>
                    <select id="chess-mode" onchange="ChessGame.updateMode()">
                        <option value="pvp">PvP Locale</option>
                        <option value="pvcpu">vs CPU</option>
                    </select>
                </div>
                <div class="control-group" id="chess-diff-group" style="display:none;">
                    <label>Abilità CPU</label>
                    <select id="chess-diff" onchange="ChessGame.reset()">
                        <option value="easy">Principiante (100 ELO)</option>
                        <option value="med">Intermedio (800 ELO)</option>
                        <option value="hard">Esperto (1500 ELO)</option>
                    </select>
                </div>
                <div class="control-group">
                    <span class="status-bar" id="chess-status">Bianco Muove</span>
                </div>
            </div>

            <div class="chess-board" id="chess-board"></div>
            <button class="btn-action" onclick="ChessGame.reset()">Reset Scacchiera</button>
        </div>

    </div>

    <script>
        /* --- VIEW MANAGEMENT --- */
        const Views = {
            open: function (viewName) {
                document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
                document.getElementById(`view-${viewName}`).classList.add('active');

                const title = document.getElementById('app-title');
                if (viewName === 'menu') title.innerText = "MASHFROG GAMES";
                if (viewName === 'tris') { title.innerText = "TRIS ULTIMATE"; TrisGame.init(); }
                if (viewName === 'chess') { title.innerText = "SCACCHI"; ChessGame.init(); }
            }
        };

        /* --- TRIS ENGINE --- */
        const TrisGame = (function () {
            const state = { board: [], active: true, player: 'X' };
            const els = {};
            const wins = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];

            function init() {
                els.board = document.getElementById('tris-board');
                els.status = document.getElementById('tris-status');
                els.mode = document.getElementById('tris-mode');
                els.diff = document.getElementById('tris-diff');
                els.diffGroup = document.getElementById('tris-diff-group');

                els.mode.addEventListener('change', () => {
                    els.diffGroup.style.display = els.mode.value === 'pvcpu' ? 'flex' : 'none';
                    reset();
                });
                reset();
            }

            function reset() {
                state.board = Array(9).fill(null);
                state.active = true;
                state.player = 'X';
                els.board.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'cell-tris';
                    btn.onclick = () => handleClick(i);
                    els.board.appendChild(btn);
                }
                els.status.innerHTML = `Tocca a <span style="color:var(--accent-primary)">X</span>`;
            }

            function handleClick(i) {
                if (!state.active || state.board[i]) return;
                if (els.mode.value === 'pvcpu' && state.player === 'O') return;

                move(i, state.player);
                if (state.active && els.mode.value === 'pvcpu' && state.player === 'O') setTimeout(cpuMove, 300);
            }

            function move(i, p) {
                state.board[i] = p;
                const cell = els.board.children[i];
                cell.innerText = p;
                cell.classList.add(p.toLowerCase());

                if (checkWin(state.board, p)) {
                    state.active = false;
                    els.status.innerText = `${p} VINCE!`;
                    highlightWin(p);
                } else if (state.board.every(c => c)) {
                    state.active = false;
                    els.status.innerText = "Pareggio!";
                } else {
                    state.player = p === 'X' ? 'O' : 'X';
                    els.status.innerHTML = `Tocca a <span style="color:var(--accent-${state.player === 'X' ? 'primary' : 'secondary'})">${state.player}</span>`;
                }
            }

            function highlightWin(p) {
                wins.forEach(c => {
                    if (c.every(i => state.board[i] === p)) c.forEach(i => els.board.children[i].classList.add('win'));
                });
            }

            function checkWin(bd, p) { return wins.some(c => c.every(i => bd[i] === p)); }

            function cpuMove() {
                if (!state.active) return;
                let idx;
                if (els.diff.value === 'easy') {
                    const empty = state.board.map((v, i) => v ? null : i).filter(v => v !== null);
                    idx = empty[Math.floor(Math.random() * empty.length)];
                } else {
                    idx = minimax(state.board, 'O').index;
                }
                if (idx !== -1) move(idx, 'O');
            }

            function minimax(bd, p) {
                const avail = bd.map((v, i) => v ? null : i).filter(v => v !== null);
                if (checkWin(bd, 'X')) return { score: -10 };
                if (checkWin(bd, 'O')) return { score: 10 };
                if (avail.length === 0) return { score: 0 };

                const moves = [];
                for (let i of avail) {
                    bd[i] = p;
                    const score = minimax(bd, p === 'O' ? 'X' : 'O').score;
                    bd[i] = null;
                    moves.push({ index: i, score });
                }

                return p === 'O' ? moves.reduce((a, b) => a.score > b.score ? a : b) : moves.reduce((a, b) => a.score < b.score ? a : b);
            }

            return { init, reset };
        })();

        /* --- CHESS ENGINE (Multi-Difficulty) --- */
        const ChessGame = (function () {
            // Simple 8x8 representation
            const initialBoard = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];

            const symbols = { 'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙', 'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟' };
            const weights = { 'p': 10, 'n': 30, 'b': 30, 'r': 50, 'q': 90, 'k': 900 };

            let board = [], turn = 'white', selected = null, validMoves = [], isOver = false;

            const els = {};

            function init() {
                els.board = document.getElementById('chess-board');
                els.status = document.getElementById('chess-status');
                els.mode = document.getElementById('chess-mode');
                els.diff = document.getElementById('chess-diff');
                els.diffGroup = document.getElementById('chess-diff-group');
                reset();
            }

            function updateMode() {
                els.diffGroup.style.display = els.mode.value === 'pvcpu' ? 'flex' : 'none';
                reset();
            }

            function reset() {
                board = JSON.parse(JSON.stringify(initialBoard));
                turn = 'white';
                selected = null;
                validMoves = [];
                isOver = false;
                els.status.innerText = "Bianco Muove";
                els.status.className = "status-bar";
                render();
            }

            function render() {
                els.board.innerHTML = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const sq = document.createElement('div');
                        sq.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                        sq.onclick = () => handleClick(r, c);

                        if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');

                        if (validMoves.some(m => m.r === r && m.c === c)) {
                            sq.classList.add(board[r][c] ? 'capture-move' : 'possible-move');
                        }

                        const p = board[r][c];
                        if (p) {
                            const s = document.createElement('span');
                            s.className = `piece ${p === p.toUpperCase() ? 'white' : 'black'}`;
                            s.innerText = symbols[p];
                            sq.appendChild(s);
                        }
                        els.board.appendChild(sq);
                    }
                }
            }

            function handleClick(r, c) {
                if (isOver) return;
                if (els.mode.value === 'pvcpu' && turn === 'black') return;

                const move = validMoves.find(m => m.r === r && m.c === c);
                if (move) {
                    execMove(move, true);
                } else {
                    const p = board[r][c];
                    if (p && ((turn === 'white' && p === p.toUpperCase()) || (turn === 'black' && p !== p.toUpperCase()))) {
                        selected = { r, c };
                        validMoves = getMoves(r, c, p, board);
                        render();
                    } else {
                        selected = null; validMoves = []; render();
                    }
                }
            }

            function execMove(move, real = false) {
                const p = board[selected.r][selected.c];
                const target = board[move.r][move.c];

                if (target && target.toLowerCase() === 'k') {
                    if (real) { isOver = true; els.status.innerHTML = `<span style="color:var(--accent-primary)">${turn.toUpperCase()} VINCE!</span>`; render(); }
                    return true;
                }

                board[move.r][move.c] = p;
                board[selected.r][selected.c] = null;
                if (p === 'P' && move.r === 0) board[move.r][move.c] = 'Q';
                if (p === 'p' && move.r === 7) board[move.r][move.c] = 'q';

                turn = turn === 'white' ? 'black' : 'white';

                if (real) {
                    els.status.innerText = `${turn === 'white' ? 'Bianco' : 'Nero'} Muove`;
                    selected = null; validMoves = []; render();
                    if (!isOver && els.mode.value === 'pvcpu' && turn === 'black') setTimeout(cpuMove, 200);
                }
                return false;
            }

            function getMoves(r, c, p, bd) {
                const moves = [];
                const type = p.toLowerCase();
                const isWhite = p === p.toUpperCase();

                // Logic compressed for brevity but standard chess rules
                const add = (nr, nc) => {
                    if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                        const t = bd[nr][nc];
                        if (!t || (t === t.toUpperCase()) !== isWhite) moves.push({ r: nr, c: nc });
                        return !t; // Continue sliding if empty
                    }
                    return false;
                };

                if (type === 'p') {
                    const d = isWhite ? -1 : 1;
                    if (!bd[r + d]?.[c]) {
                        moves.push({ r: r + d, c: c });
                        if ((isWhite ? r === 6 : r === 1) && !bd[r + d * 2]?.[c]) moves.push({ r: r + d * 2, c: c });
                    }
                    if (bd[r + d]?.[c - 1] && (bd[r + d][c - 1] === bd[r + d][c - 1].toUpperCase()) !== isWhite) moves.push({ r: r + d, c: c - 1 });
                    if (bd[r + d]?.[c + 1] && (bd[r + d][c + 1] === bd[r + d][c + 1].toUpperCase()) !== isWhite) moves.push({ r: r + d, c: c + 1 });
                } else if (type === 'n') {
                    [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]].forEach(([dr, dc]) => add(r + dr, c + dc));
                } else if (type === 'k') {
                    [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => add(r + dr, c + dc));
                } else {
                    const dirs = type === 'r' ? [[0, 1], [0, -1], [1, 0], [-1, 0]] : type === 'b' ? [[1, 1], [1, -1], [-1, 1], [-1, -1]] : [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
                    dirs.forEach(([dr, dc]) => {
                        let nr = r + dr, nc = c + dc;
                        while (add(nr, nc)) { nr += dr; nc += dc; }
                    });
                }
                return moves;
            }

            /* --- ADVANCED AI --- */
            function cpuMove() {
                if (isOver) return;
                const diff = els.diff.value;
                const depth = diff === 'easy' ? 0 : diff === 'med' ? 1 : 2; // +1 effective depth due to current ply

                // Get all moves for Black
                let moves = getAllMoves('black', board);
                if (!moves.length) return;

                let bestMove = null;
                let bestVal = -Infinity;

                for (let m of moves) {
                    // Execute Virtual Move
                    const saved = board[m.to.r][m.to.c];
                    board[m.to.r][m.to.c] = board[m.from.r][m.from.c];
                    board[m.from.r][m.from.c] = null;

                    let val = -minimaxScore(depth, -Infinity, Infinity, 'white');

                    // Add noise for variation
                    val += Math.random() * (diff === 'hard' ? 1 : 5);

                    // Undo
                    board[m.from.r][m.from.c] = board[m.to.r][m.to.c];
                    board[m.to.r][m.to.c] = saved;

                    if (val > bestVal) { bestVal = val; bestMove = m; }
                }

                if (bestMove) {
                    selected = bestMove.from;
                    execMove(bestMove.to, true);
                }
            }

            // Minimax with Alpha-Beta Pruning
            function minimaxScore(depth, alpha, beta, turnColor) {
                if (depth === 0) return evaluate(board, turnColor);

                const moves = getAllMoves(turnColor, board);
                if (!moves.length) return 0;

                let maxEval = -Infinity;

                for (let m of moves) {
                    const saved = board[m.to.r][m.to.c];
                    board[m.to.r][m.to.c] = board[m.from.r][m.from.c];
                    board[m.from.r][m.from.c] = null;

                    // King Capture Check (Arcade Mode)
                    if (saved && saved.toLowerCase() === 'k') {
                        // If we captured King, this path is infinity good
                        board[m.from.r][m.from.c] = board[m.to.r][m.to.c];
                        board[m.to.r][m.to.c] = saved;
                        return 10000 + depth;
                    }

                    const eval = -minimaxScore(depth - 1, -beta, -alpha, turnColor === 'white' ? 'black' : 'white');

                    board[m.from.r][m.from.c] = board[m.to.r][m.to.c];
                    board[m.to.r][m.to.c] = saved;

                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval;
            }

            function getAllMoves(color, bd) {
                const ms = [];
                const isWhite = color === 'white';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = bd[r][c];
                        if (p && (p === p.toUpperCase()) === isWhite) {
                            getMoves(r, c, p, bd).forEach(t => ms.push({ from: { r, c }, to: t }));
                        }
                    }
                }
                return ms.sort(() => Math.random() - 0.5); // Shuffle for randomness in easy mode
            }

            function evaluate(bd, colorTurn) {
                let score = 0;
                // Simple material count from active player's perspective
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = bd[r][c];
                        if (p) {
                            const val = weights[p.toLowerCase()];
                            const isWhite = p === p.toUpperCase();
                            // If it's my piece +val, enemy -val
                            const isMyPiece = (colorTurn === 'white' && isWhite) || (colorTurn === 'black' && !isWhite);

                            // Positional Bonus (very simple centralized bonus)
                            let posBonus = 0;
                            if ((r === 3 || r === 4) && (c === 3 || c === 4)) posBonus = 2;

                            score += isMyPiece ? (val + posBonus) : -(val + posBonus);
                        }
                    }
                }
                return score;
            }

            return { init, reset, updateMode };
        })();
    </script>
</body>

</html>