<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tris & Scacchi Premium</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --container-bg: #1e293b;
            --text-color: #f8fafc;
            --accent-primary: #38bdf8;
            --accent-secondary: #f472b6;
            --grid-line: #334155;
            --hover-cell: #334155;
            --font-main: 'Segoe UI', system-ui, sans-serif;

            /* Chess Colors */
            --chess-light: #e2e8f0;
            --chess-dark: #475569;
            --chess-highlight: rgba(56, 189, 248, 0.5);
            --chess-moved: rgba(244, 114, 182, 0.3);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            font-family: var(--font-main);
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 1rem;
        }

        .app-container {
            background-color: var(--container-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 550px;
            /* Slightly wider for Chess */
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            animation: fadeIn 0.6s ease-out;
            position: relative;
        }

        h1 {
            text-align: center;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 0.5rem;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* --- MENU SYSTEM --- */
        .view-section {
            display: none;
            flex-direction: column;
            gap: 1.5rem;
        }

        .view-section.active {
            display: flex;
            animation: fadeIn 0.4s ease-out;
        }

        .menu-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .game-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--grid-line);
            border-radius: 1rem;
            padding: 2rem 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .game-card:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-5px);
            border-color: var(--accent-primary);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .game-icon {
            font-size: 3rem;
        }

        .game-title {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .back-btn {
            background: transparent;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 0.9rem;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: -1rem;
            width: fit-content;
        }

        .back-btn:hover {
            opacity: 1;
            color: var(--accent-primary);
        }

        /* --- COMMON GAME CONTROLS --- */
        .settings,
        .scores {
            background: rgba(0, 0, 0, 0.2);
            padding: 1rem;
            border-radius: 0.75rem;
        }

        .control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            font-size: 0.85rem;
            font-weight: 600;
            opacity: 0.8;
        }

        select,
        button.control-btn {
            background: var(--bg-color);
            color: white;
            border: 1px solid var(--grid-line);
            padding: 0.4rem 0.8rem;
            border-radius: 0.4rem;
            cursor: pointer;
            font-family: inherit;
        }

        .status-bar {
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            min-height: 1.5em;
        }

        .btn-action {
            width: 100%;
            padding: 0.8rem;
            border: none;
            border-radius: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            font-size: 1rem;
            background: linear-gradient(135deg, var(--accent-primary), #0284c7);
            color: white;
            transition: opacity 0.2s;
        }

        .btn-action:hover {
            opacity: 0.9;
        }

        /* --- TRIS STYLES --- */
        .tris-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
            aspect-ratio: 1;
        }

        .cell-tris {
            background: var(--bg-color);
            border-radius: 1rem;
            border: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: 800;
            cursor: pointer;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: all 0.2s;
        }

        .cell-tris:hover:not(:disabled) {
            background: var(--hover-cell);
            transform: translateY(-2px);
        }

        .cell-tris.x {
            color: var(--accent-primary);
            text-shadow: 0 0 10px rgba(56, 189, 248, 0.4);
        }

        .cell-tris.o {
            color: var(--accent-secondary);
            text-shadow: 0 0 10px rgba(244, 114, 182, 0.4);
        }

        .cell-tris.win {
            background: rgba(255, 255, 255, 0.1);
            animation: pulse 1.5s infinite;
        }

        /* --- CHESS STYLES --- */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            border: 4px solid var(--container-bg);
            aspect-ratio: 1;
            user-select: none;
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.2rem;
            cursor: pointer;
            position: relative;
        }

        .square.light {
            background-color: var(--chess-light);
            color: black;
        }

        .square.dark {
            background-color: var(--chess-dark);
            color: white;
        }

        .square.selected {
            box-shadow: inset 0 0 0 4px var(--accent-primary);
        }

        .square.possible-move::after {
            content: '';
            width: 12px;
            height: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            position: absolute;
        }

        .square.capture-move::after {
            content: '';
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255, 0, 0, 0.4);
            border-radius: 50%;
            position: absolute;
        }

        .piece {
            cursor: grab;
            transition: transform 0.1s;
        }

        .piece.white {
            color: #f8fafc;
            text-shadow: 0 2px 2px rgba(0, 0, 0, 0.5);
        }

        .piece.black {
            color: #000000;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
        }

        .chess-controls {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem;
            opacity: 0.8;
            padding: 0 0.5rem;
        }

        /* --- ANIMATIONS --- */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.2);
            }

            70% {
                box-shadow: 0 0 0 10px transparent;
            }

            100% {
                box-shadow: 0 0 0 0 transparent;
            }
        }

        @media (max-width: 400px) {
            .app-container {
                padding: 1rem;
            }

            .cell-tris {
                font-size: 2.5rem;
            }

            .square {
                font-size: 1.8rem;
            }
        }
    </style>
</head>

<body>

    <div class="app-container">
        <h1 id="app-title">MASHFROG GAMES</h1>

        <!-- MENU VIEW -->
        <div id="view-menu" class="view-section active">
            <div class="menu-grid">
                <div class="game-card" onclick="Views.open('tris')">
                    <div class="game-icon">❌⭕</div>
                    <div class="game-title">TRIS ULTIMATE</div>
                    <div style="font-size: 0.8rem; opacity: 0.7;">Classic & vs CPU</div>
                </div>
                <div class="game-card" onclick="Views.open('chess')">
                    <div class="game-icon">♟️</div>
                    <div class="game-title">SCACCHI</div>
                    <div style="font-size: 0.8rem; opacity: 0.7;">PvP & vs CPU</div>
                </div>
            </div>
        </div>

        <!-- TRIS VIEW -->
        <div id="view-tris" class="view-section">
            <button class="back-btn" onclick="Views.open('menu')">← Menu</button>

            <div class="settings">
                <div class="control-group">
                    <label>Modalità</label>
                    <select id="tris-mode" onchange="TrisGame.reset()">
                        <option value="pvp">PvP Locale</option>
                        <option value="pvcpu">vs CPU</option>
                    </select>
                </div>
                <div class="control-group" id="tris-diff-group" style="display:none;">
                    <label>Difficoltà</label>
                    <select id="tris-diff" onchange="TrisGame.reset()">
                        <option value="easy">Facile</option>
                        <option value="hard">Impossibile</option>
                    </select>
                </div>
                <div class="control-group">
                    <span class="status-bar" id="tris-status">Tocca a X</span>
                </div>
            </div>

            <div class="tris-board" id="tris-board"></div>

            <div class="tris-scores"
                style="display:flex; justify-content:space-between; background:rgba(0,0,0,0.2); padding:0.8rem; border-radius:0.5rem; font-size:0.9rem;">
                <span>X: <strong id="score-x">0</strong></span>
                <span>O: <strong id="score-o">0</strong></span>
            </div>

            <button class="btn-action" onclick="TrisGame.reset()">Nuova Partita</button>
        </div>

        <!-- CHESS VIEW -->
        <div id="view-chess" class="view-section">
            <button class="back-btn" onclick="Views.open('menu')">← Menu</button>

            <div class="settings" style="margin-bottom: 0.5rem;">
                <div class="control-group">
                    <label>Modalità</label>
                    <select id="chess-mode" onchange="ChessGame.reset()">
                        <option value="pvp">PvP Locale</option>
                        <option value="pvcpu">vs CPU (Facile)</option>
                    </select>
                </div>
                <div class="control-group">
                    <span class="status-bar" id="chess-status">Bianco Muove</span>
                </div>
            </div>

            <div class="chess-board" id="chess-board"></div>

            <div class="chess-controls">
                <span id="chess-captured-w"></span>
                <span id="chess-captured-b"></span>
            </div>

            <button class="btn-action" onclick="ChessGame.reset()">Reset Scacchiera</button>
        </div>

    </div>

    <script>
        /* --- VIEW MANAGEMENT --- */
        const Views = {
            open: function (viewName) {
                document.querySelectorAll('.view-section').forEach(el => el.classList.remove('active'));
                document.getElementById(`view-${viewName}`).classList.add('active');

                const title = document.getElementById('app-title');
                if (viewName === 'menu') title.innerText = "MASHFROG GAMES";
                if (viewName === 'tris') {
                    title.innerText = "TRIS ULTIMATE";
                    TrisGame.resize();
                }
                if (viewName === 'chess') {
                    title.innerText = "SCACCHI";
                    ChessGame.init();
                }
            }
        };

        /* --- TRIS ENGINE (Preserved Logic) --- */
        const TrisGame = (function () {
            const state = {
                board: Array(9).fill(null),
                active: true,
                player: 'X',
                scores: { X: 0, O: 0 }
            };

            const els = {
                board: document.getElementById('tris-board'),
                status: document.getElementById('tris-status'),
                mode: document.getElementById('tris-mode'),
                diff: document.getElementById('tris-diff'),
                diffGroup: document.getElementById('tris-diff-group'),
                sx: document.getElementById('score-x'),
                so: document.getElementById('score-o')
            };

            const wins = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];

            function init() {
                createBoard();
                reset();
                els.mode.addEventListener('change', () => {
                    els.diffGroup.style.display = els.mode.value === 'pvcpu' ? 'flex' : 'none';
                    reset();
                });
            }

            function createBoard() {
                els.board.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'cell-tris';
                    btn.onclick = () => handleClick(i);
                    els.board.appendChild(btn);
                }
            }

            function handleClick(i) {
                if (!state.active || state.board[i]) return;
                const isCpuTurn = els.mode.value === 'pvcpu' && state.player === 'O';
                if (isCpuTurn) return;

                move(i, state.player);

                if (state.active && els.mode.value === 'pvcpu' && state.player === 'O') {
                    setTimeout(cpuMove, 500);
                }
            }

            function move(i, p) {
                state.board[i] = p;
                const cell = els.board.children[i];
                cell.innerText = p;
                cell.classList.add(p.toLowerCase());

                if (checkWin(state.board, p)) {
                    end(p);
                } else if (state.board.every(c => c)) {
                    end(null);
                } else {
                    state.player = p === 'X' ? 'O' : 'X';
                    updateStatus();
                }
            }

            function updateStatus() {
                els.status.innerHTML = `Tocca a <span style="color:var(--accent-${state.player === 'X' ? 'primary' : 'secondary'})">${state.player}</span>`;
            }

            function end(winner) {
                state.active = false;
                if (winner) {
                    els.status.innerHTML = `<span style="color:var(--accent-${winner === 'X' ? 'primary' : 'secondary'})">${winner} VINCE!</span>`;
                    state.scores[winner]++;
                    highlightWin(winner);
                } else {
                    els.status.innerText = "Pareggio!";
                }
                updateScoreUI();
            }

            function highlightWin(p) {
                wins.forEach(c => {
                    if (c.every(i => state.board[i] === p)) {
                        c.forEach(i => els.board.children[i].classList.add('win'));
                    }
                });
            }

            function updateScoreUI() {
                els.sx.innerText = state.scores.X;
                els.so.innerText = state.scores.O;
            }

            function reset() {
                state.board.fill(null);
                state.active = true;
                state.player = 'X';
                Array.from(els.board.children).forEach(b => {
                    b.innerText = '';
                    b.className = 'cell-tris';
                });
                updateStatus();
            }

            function checkWin(bd, p) {
                return wins.some(c => c.every(i => bd[i] === p));
            }

            /* CPU Logic (Minimax) */
            function cpuMove() {
                if (!state.active) return;
                const diff = els.diff.value;
                let idx = -1;

                if (diff === 'easy') {
                    const empty = state.board.map((v, i) => v ? null : i).filter(v => v !== null);
                    idx = empty[Math.floor(Math.random() * empty.length)];
                } else {
                    idx = minimax(state.board, 'O').index;
                }
                if (idx !== -1) move(idx, 'O');
            }

            function minimax(newBoard, player) {
                const avail = newBoard.map((v, i) => v ? null : i).filter(v => v !== null);

                if (checkWin(newBoard, 'X')) return { score: -10 };
                if (checkWin(newBoard, 'O')) return { score: 10 };
                if (avail.length === 0) return { score: 0 };

                const moves = [];
                for (let i of avail) {
                    const move = {};
                    move.index = i;
                    newBoard[i] = player;
                    if (player === 'O') {
                        move.score = minimax(newBoard, 'X').score;
                    } else {
                        move.score = minimax(newBoard, 'O').score;
                    }
                    newBoard[i] = null;
                    moves.push(move);
                }

                let bestMove;
                if (player === 'O') {
                    let bestScore = -10000;
                    for (let m of moves) {
                        if (m.score > bestScore) { bestScore = m.score; bestMove = m; }
                    }
                } else {
                    let bestScore = 10000;
                    for (let m of moves) {
                        if (m.score < bestScore) { bestScore = m.score; bestMove = m; }
                    }
                }
                return bestMove;
            }

            return { init, reset, resize: () => { } };
        })();
        TrisGame.init();

        /* --- CHESS ENGINE (PvP & AI) --- */
        const ChessGame = (function () {
            // Representation: 8x8 array. Uppercase = White, Lowercase = Black.
            const initialBoard = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null, null],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];

            const symbols = {
                'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
                'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
            };

            // Material values
            const weights = {
                'p': 10, 'n': 30, 'b': 30, 'r': 50, 'q': 90, 'k': 900
            };

            let board = [];
            let turn = 'white'; // 'white' or 'black'
            let selected = null; // {r, c}
            let validMoves = []; // Array of {r, c}
            let isGameOver = false;

            const boardEl = document.getElementById('chess-board');
            const statusEl = document.getElementById('chess-status');
            const modeSel = document.getElementById('chess-mode');

            function init() {
                if (board.length === 0) reset();
                else render();
            }

            function reset() {
                board = JSON.parse(JSON.stringify(initialBoard));
                turn = 'white';
                selected = null;
                validMoves = [];
                isGameOver = false;
                statusEl.innerText = "Bianco Muove";
                statusEl.style.color = "var(--text-color)";
                render();
            }

            function render() {
                boardEl.innerHTML = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const sq = document.createElement('div');
                        sq.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                        sq.onclick = () => handleSquareClick(r, c);

                        if (selected && selected.r === r && selected.c === c) sq.classList.add('selected');

                        const isMove = validMoves.some(m => m.r === r && m.c === c);
                        if (isMove) {
                            const isCapture = board[r][c] !== null;
                            sq.classList.add(isCapture ? 'capture-move' : 'possible-move');
                        }

                        const piece = board[r][c];
                        if (piece) {
                            const pEl = document.createElement('span');
                            pEl.className = `piece ${isWhite(piece) ? 'white' : 'black'}`;
                            pEl.innerText = symbols[piece];
                            sq.appendChild(pEl);
                        }
                        boardEl.appendChild(sq);
                    }
                }
            }

            function isWhite(p) { return p === p.toUpperCase(); }

            function handleSquareClick(r, c) {
                if (isGameOver) return;
                if (modeSel.value === 'pvcpu' && turn === 'black') return; // Wait for CPU

                // Move?
                const move = validMoves.find(m => m.r === r && m.c === c);
                if (move) {
                    executeMove(move, true);
                    return;
                }

                // Select?
                const piece = board[r][c];
                if (piece) {
                    const pieceIsWhite = isWhite(piece);
                    if ((turn === 'white' && pieceIsWhite) || (turn === 'black' && !pieceIsWhite)) {
                        selected = { r, c };
                        validMoves = getValidMoves(r, c, piece, board);
                        render();
                        return;
                    }
                }

                // Deselect
                selected = null;
                validMoves = [];
                render();
            }

            function executeMove(move, real = false) {
                const p = board[selected.r][selected.c];
                const target = board[move.r][move.c];

                // Win condition (King Capture)
                if (target && target.toLowerCase() === 'k') {
                    if (real) {
                        statusEl.innerHTML = `<span style="color:var(--accent-primary)">${turn === 'white' ? 'BIANCO' : 'NERO'} VINCE!</span>`;
                        isGameOver = true;
                        render();
                    }
                    return true; // Game Ended
                }

                board[move.r][move.c] = p;
                board[selected.r][selected.c] = null;

                // Pawn Promotion
                if (p === 'P' && move.r === 0) board[move.r][move.c] = 'Q';
                if (p === 'p' && move.r === 7) board[move.r][move.c] = 'q';

                // Switch turn
                turn = turn === 'white' ? 'black' : 'white';

                if (real) {
                    statusEl.innerText = `${turn === 'white' ? 'Bianco' : 'Nero'} Muove`;
                    selected = null;
                    validMoves = [];
                    render();

                    // Trigger AI if needed
                    if (!isGameOver && modeSel.value === 'pvcpu' && turn === 'black') {
                        setTimeout(cpuMove, 300);
                    }
                }
                return false;
            }

            function getValidMoves(r, c, p, currentBoard) {
                const moves = [];
                const type = p.toLowerCase();
                const directions = {
                    'r': [[0, 1], [0, -1], [1, 0], [-1, 0]],
                    'b': [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                    'q': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]],
                    'n': [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]],
                    'k': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
                };

                const isPWhite = p === p.toUpperCase();

                if (type === 'p') {
                    const dir = isPWhite ? -1 : 1;
                    // Move forward 1
                    if (onBoard(r + dir, c) && !currentBoard[r + dir][c]) {
                        moves.push({ r: r + dir, c: c });
                        // Move forward 2
                        const startRow = isPWhite ? 6 : 1;
                        if (r === startRow && !currentBoard[r + (dir * 2)][c]) {
                            moves.push({ r: r + (dir * 2), c: c });
                        }
                    }
                    // Capture
                    [[dir, 1], [dir, -1]].forEach(([dr, dc]) => {
                        if (onBoard(r + dr, c + dc)) {
                            const target = currentBoard[r + dr][c + dc];
                            if (target && (target === target.toUpperCase()) !== isPWhite) {
                                moves.push({ r: r + dr, c: c + dc });
                            }
                        }
                    });
                } else if (type === 'n' || type === 'k') {
                    directions[type].forEach(([dr, dc]) => {
                        const nr = r + dr, nc = c + dc;
                        if (onBoard(nr, nc)) {
                            const target = currentBoard[nr][nc];
                            if (!target || (target === target.toUpperCase()) !== isPWhite) {
                                moves.push({ r: nr, c: nc });
                            }
                        }
                    });
                } else {
                    // Sliding pieces
                    directions[type].forEach(([dr, dc]) => {
                        let nr = r + dr, nc = c + dc;
                        while (onBoard(nr, nc)) {
                            const target = currentBoard[nr][nc];
                            if (!target) {
                                moves.push({ r: nr, c: nc });
                            } else {
                                if ((target === target.toUpperCase()) !== isPWhite) moves.push({ r: nr, c: nc });
                                break;
                            }
                            nr += dr; nc += dc;
                        }
                    });
                }
                return moves;
            }

            function onBoard(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

            /* --- Chess AI --- */
            function cpuMove() {
                if (isGameOver) return;

                // 1. Gather all black valid moves
                const allMoves = getAllMoves('black', board);

                if (allMoves.length === 0) return; // Stalemate/Mate

                let bestMove = null;
                let bestValue = -Infinity;

                // Simple search (Depth 1 + Aggressive Capture)
                for (let m of allMoves) {
                    // Simulate
                    const saved = board[m.to.r][m.to.c];
                    board[m.to.r][m.to.c] = board[m.from.r][m.from.c];
                    board[m.from.r][m.from.c] = null;

                    // Evaluate
                    const value = evaluateBoard(board);

                    // Add Small randomness to break ties
                    const finalValue = value + (Math.random() * 5);

                    if (finalValue > bestValue) {
                        bestValue = finalValue;
                        bestMove = m;
                    }

                    // Undo
                    board[m.from.r][m.from.c] = board[m.to.r][m.to.c];
                    board[m.to.r][m.to.c] = saved;
                }

                if (bestMove) {
                    selected = bestMove.from;
                    executeMove(bestMove.to, true);
                }
            }

            function getAllMoves(color, currentBoard) {
                const moves = [];
                const isWhiteTurn = color === 'white';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = currentBoard[r][c];
                        if (p && (p === p.toUpperCase()) === isWhiteTurn) {
                            const pieceMoves = getValidMoves(r, c, p, currentBoard);
                            pieceMoves.forEach(target => {
                                moves.push({ from: { r, c }, to: target });
                            });
                        }
                    }
                }
                return moves;
            }

            function evaluateBoard(bd) {
                let score = 0;
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const p = bd[r][c];
                        if (p) {
                            const val = weights[p.toLowerCase()];
                            const isWhite = p === p.toUpperCase();
                            // Black maximizes score (positive for black in this specific implementation logic? 
                            // Wait, usually white is positive. Let's stick to standard: White +, Black -
                            // IF so, Black wants to minimize.
                            // BUT in my cpuMove logic above: `if (finalValue > bestValue)` implies maximizing.
                            // So I should make Black pieces Positive for the AI's perspective?
                            // Let's Keep it simple: Evaluator returns score from *Black's Perspective*.

                            if (!isWhite) score += val; // Black adds to score
                            else score -= val;          // White subtracts
                        }
                    }
                }
                return score;
            }

            return { init, reset };
        })();
    </script>
</body>

</html>